# 复杂度


## 为什么需要复杂度分析？
1. 测试结果非常依赖测试环境
2. 测试结果受数据规模的影响很大

所以，我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法。
## 大 O 复杂度表示法
{{< raw >}}
\[ T(n) = O(f(n))\]
{{< /raw >}}
其中，T(n)，它表示代码执行的时间；n 表
示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n)
来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。

大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是
表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度
（asymptotic time complexity），简称时间复杂度。

## 时间复杂度分析
### 只关注循环执行次数最多的一段代码
我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了
### 加法法则：总复杂度等于量级最大的那段代码的复杂度
### 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
## 几种常见时间复杂度实例分析
### O(1)
```
int i = 8;
int j = 6;
int sum = i+j;
```
一般情况下，只要算法中不存在循环语句、递归语句，即使有成千
上万行的代码，其时间复杂度也是Ο(1)。
### O(logn)、O(nlogn)
```
i = 1;
while (i <= n) {
   i =  i * 2
}
```
如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是
O(nlogn) 了。而且，O(nlogn) 也是一种非常常见的算法时间复杂度。
### O(m+n)、O(m*n)
```
int cal(int m, int n) {
    int sum_1 = 0;
    int i = 1;
    for (;i<m;++i) {
        sum_1 = sum_1 + i;
    }
    
    int sum_2 = 0;
    int j = 1;
    for (;j<n;++j) {
        sum_2 = sum_2 + j;
    }
    return sum_1 + sum_2;
}
```
从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级
大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，
上面代码的时间复杂度就是 O(m+n)。

## 空间复杂度分析
空间复杂度全称就是渐进空间复杂度（asymptotic space
complexity），表示算法的存储空间与数据规模之间的增长关系。
```
void print(int n) {
    int i = 0;
    int[] a = new int[n];
    for (i; i <n; ++i) {
        a[i] = i * i;
    }
    
    for (i = n-1; i >= 0; --i) {
        print out a[i]
    }
}
```
跟时间复杂度分析一样，我们可以看到，第 2 行代码中，我们申请了一个空间存储变量 i，
但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小
为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空
间复杂度就是 O(n)。
## 最好、最坏情况时间复杂度
```
// n 表示数组 array 的长度
int find(int[] array, int n, int x) {
    int i = 0;
    int pos = -1;
    for (; i < n; ++i) {
        if (array[i] == x) {
            pos = i;
            break;
        }   
    }
    return pos;
}
```
要查找的变量 x 可能出现在数组的任意位置。如果数组中第一个元素正好是要查找
的变量 x，那就不需要继续遍历剩下的 n-1 个数据了，那时间复杂度就是 O(1)。但如果数
组中不存在变量 x，那我们就需要把整个数组都遍历一遍，时间复杂度就成了 O(n)。所
以，不同的情况下，这段代码的时间复杂度是不一样的。

为了表示代码在不同情况下的不同时间复杂度，我们需要引入三个概念：最好情况时间复杂
度、最坏情况时间复杂度和平均情况时间复杂度。

顾名思义，**最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度**。就
像我们刚刚讲到的，在最理想的情况下，要查找的变量 x 正好是数组的第一个元素，这个
时候对应的时间复杂度就是最好情况时间复杂度。

同理，**最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。**就像刚
举的那个例子，如果数组中没有要查找的变量 x，我们需要把整个数组都遍历一遍才行，所
以这种最糟糕情况下对应的时间复杂度就是最坏情况时间复杂度。

## 平均情况时间复杂度
平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。

## 均摊时间复杂度
```
// array 表示一个长度为 n 的数组
// 代码中的 array.length 就等于 n
int[] array = new int[n];
int count = 0;
void insert(int val) {
    if (count == array.length) {
        int sum = 0;
        for (int i = 0; i < array.length; ++i) {
            sum = sum + array[i];
        }
        array[0] = sum;
        count = 1;
    }
    array[count] = val;
    ++count;
}
```
针对这种特殊的场景，我们引入了一种更加简单的分析方法：摊还分析法，通过摊还分析得
到的时间复杂度我们起了一个名字，叫均摊时间复杂度。

每一次 O(n) 的插入操作，都会跟着 n-1 次
O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊
下来，这一组连续的操作的均摊时间复杂度就是 O(1)。

**均摊时间复杂度就是一种特殊的平均时间复杂度**
